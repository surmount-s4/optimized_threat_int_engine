This is the final, consolidated **Master Design Document**. It integrates every concept we discussed—speed, segregation, miscellaneous handling, and the Go/Docker stack—into a single source of truth.

I have added one critical "missing piece" to this final version: **Change Detection**. The logic now includes checking the "Last Modified" timestamp of files so your system doesn't waste resources re-scanning files that haven't changed.

-----

# **Threat Intelligence Platform (TIP) – Master Implementation Guide**

## **1. Executive Summary**

This project builds a scalable, high-speed Threat Intelligence Platform using **Golang**. It ingests mixed data from a local directory, extracts IOCs (IPs, Hashes, Domains) using Regex, and serves them via an API.

**Core Philosophy:**

  * **Tiered Storage:** Metadata in **ClickHouse**, Blobs in **MinIO**, Cache in **Redis**.
  * **Zero-Waste:** "Clean" or "Miscellaneous" files are offloaded to object storage, not the main DB.
  * **Deterministic:** File IDs are generated by hashing the file path, ensuring idempotency.

-----

## **2. Architecture & Data Flow**

### **The Pipeline**

1.  **Ingestion (Go Worker Pool):**
      * Walks the directory.
      * **Check:** Has file changed? (Compare `mod_time` with DB).
      * **Action:** If new/changed $\rightarrow$ Extract IOCs.
2.  **Segregation:**
      * **IOCs Found:** Push to **ClickHouse** (`ioc_store`) & **RedisBloom**.
      * **No IOCs (Misc):** Upload content to **MinIO**; Log metadata to **ClickHouse** (`file_registry`).
3.  **Access (Go API):**
      * **Check:** Queries Redis Bloom Filter first (\<1ms).
      * **Context:** Streams raw files from MinIO upon request.

-----

## **3. Infrastructure (Docker Compose)**

Save as `docker-compose.yml`.

```yaml
version: '3.8'

services:
  # 1. ClickHouse (High-speed Columnar DB)
  clickhouse:
    image: clickhouse/clickhouse-server:latest
    ports:
      - "8123:8123" # HTTP
      - "9000:9000" # Native
    volumes:
      - ch_data:/var/lib/clickhouse
      - ./init-db:/docker-entrypoint-initdb.d
    ulimits:
      nofile:
        soft: 262144
        hard: 262144

  # 2. Redis Stack (Cache + Bloom Filter)
  redis:
    image: redis/redis-stack:latest
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # 3. MinIO (Object Storage for Misc Data)
  minio:
    image: minio/minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: "admin"
      MINIO_ROOT_PASSWORD: "SuperSecretPassword123"
    volumes:
      - minio_data:/data

  # 4. Qdrant (Optional: Vector Search for fuzzy matching)
  qdrant:
    image: qdrant/qdrant
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage

volumes:
  ch_data:
  redis_data:
  minio_data:
  qdrant_data:
```

-----

## **4. Database Schemas**

Save as `init-db/init.sql`.

```sql
CREATE DATABASE IF NOT EXISTS threat_intel;

-- 1. File Registry: Tracks the source of data
CREATE TABLE IF NOT EXISTS threat_intel.file_registry (
    file_id String,           -- SHA256(file_path)
    file_path String,
    last_modified DateTime,   -- Used for Change Detection
    scan_status Enum('pending', 'clean', 'infected', 'misc', 'failed'),
    minio_key String,         -- Link to MinIO if moved
    processed_at DateTime DEFAULT now()
) ENGINE = MergeTree()
ORDER BY file_id;

-- 2. IOC Store: The Search Index
CREATE TABLE IF NOT EXISTS threat_intel.ioc_store (
    ioc_value String,
    ioc_type Enum('ipv4', 'ipv6', 'domain', 'url', 'md5', 'sha256'),
    source_file_id String,    -- Link to file_registry
    malware_family String DEFAULT 'Unknown',
    
    -- Bloom Filter Index for skipping blocks
    INDEX idx_ioc ioc_value TYPE bloom_filter GRAMS 3
) ENGINE = MergeTree()
ORDER BY (ioc_type, ioc_value);
```

-----

## **5. Golang Application Specification**

Pass this section to your IDE Agent to generate the code.

### **Project Structure**

```text
/tip-server
├── cmd/
│   ├── ingestor/       # (Main) Crawler & Extractor
│   └── api/            # (Main) HTTP Server
├── internal/
│   ├── db/             # Wrappers for Redis, CH, MinIO
│   ├── extractor/      # Regex Patterns
│   └── models/         # Structs (IOC, FileMetadata)
├── go.mod
└── docker-compose.yml
```

### **Component Logic Requirements**

#### **A. Package: `internal/extractor`**

  * **Patterns:** Pre-compile Regex for:
      * IPv4: `\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b`
      * MD5: `\b[a-fA-F0-9]{32}\b`
      * Domain: `(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}`
  * **Function:** `Scan(content []byte) (map[string][]string, error)`
      * Returns a map where Key = Type (e.g., "ipv4") and Value = List of matches.

#### **B. Package: `cmd/ingestor` (The Worker)**

  * **Change Detection:** Before processing a file, query ClickHouse `file_registry` with the `file_id`.
      * If `DB.last_modified == File.last_modified`, **SKIP** (File hasn't changed).
  * **Worker Pool:** Create 50 Goroutines.
  * **Logic:**
    1.  Read File.
    2.  Run `Scan()`.
    3.  **If IOCs Found:**
          * Insert to ClickHouse `ioc_store` (Batch Insert 1000 rows at a time).
          * Add to Redis: `BF.ADD ioc_bloom <value>`.
          * Update `file_registry` status = `infected`.
    4.  **If No IOCs (Misc):**
          * Upload to MinIO Bucket `misc-data`.
          * Update `file_registry` status = `misc`, `minio_key` = `file_id`.

#### **C. Package: `cmd/api` (The Server)**

  * **Framework:** Use **Gofiber/fiber**.
  * **Endpoint: POST `/check`**
      * Input: `{"iocs": ["1.2.3.4", "bad.com"]}`.
      * **Step 1:** Pipeline Redis `BF.EXISTS` for all inputs. Filter out misses.
      * **Step 2:** Query ClickHouse `ioc_store` ONLY for the hits.
      * **Step 3:** Return JSON with Verdict and `source_file_id`.
  * **Endpoint: GET `/context/:file_id`**
      * Input: `file_id` (hash).
      * **Step 1:** Query ClickHouse `file_registry` to get `minio_key`.
      * **Step 2:** Stream file from MinIO to HTTP response.

-----

## **6. How to Run (Prompt for User)**

1.  **Spin up Infra:** `docker-compose up -d`
2.  **Initialize DB:** (Happens automatically via `init.sql`)
3.  **Run Ingestor:** `go run cmd/ingestor/main.go` (Point it to your VM folder).
4.  **Start API:** `go run cmd/api/main.go`.


Component,Technology,Role
Backend/API,Golang (Fiber),High-concurrency ingestion and REST API serving.
Primary DB,ClickHouse,OLAP database for massive scale IOC storage and fast aggregation.
Cache/Filter,Redis (Stack),"Bloom Filters for instant ""exists"" checks; Hot caching."
Blob Storage,MinIO,"S3-compatible storage for raw files and ""Miscellaneous"" context."
Vector DB,Qdrant,"(Optional) Semantic search for fuzzy text matching (domains, ransom notes)."

-----

### **Final Instruction for the Agent**

> "You are an expert Golang Systems Engineer. Using the architecture and schema defined in this 'Master Implementation Guide', please generate the `go.mod` file and the complete code for `cmd/ingestor/main.go`. Focus on the Worker Pool pattern and the ClickHouse batch insertion logic."